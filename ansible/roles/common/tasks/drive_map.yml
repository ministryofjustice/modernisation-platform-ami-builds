# Newer EC2 types are Nitro based and use NVMe spec. The NVMe device name can
# change depending on the order in which the devices respond during instance
# boot. Therefore to ensure we target the correct drive we map the ebs device
# name to the NVMe name via the device serial number, which is consistent
# See https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/nvme-ebs-volumes.html

- name: get ec2 metadata facts
  amazon.aws.ec2_metadata_facts:

- name: gather ec2 facts # this step is only really required when running Ansible as a Packer provisioner, as dynamic inventory is not available
  amazon.aws.ec2_instance_info:
    instance_ids: "{{ ansible_ec2_instance_id }}" # this is generally set in aws_ec2 group vars but can be set elsewhere, e.g. at command line when running Packer
    region: eu-west-2
  register: ec2_info
  become: no # this is required when running with Packer

- name: get ebs device names and volume ids
  ansible.builtin.set_fact:
    ebs_devices: "{{ ebs_devices | default({}) | combine({item.device_name: (item.volume_id | regex_replace('^(vol-)', 'vol')) }) }}"
  loop: "{{ ebs_devices_temp }}"
  vars:
    ebs_devices_temp: "{{ ec2_info.instances[0].block_device_mappings | json_query('[*].{volume_id: ebs.volume_id, device_name: device_name}') }}" # | items2dict(key_name='device_name', value_name='volume_id'

- debug:
    var: ebs_devices

- name: get nvme device names and volume ids
  ansible.builtin.set_fact:
    nvme_devices: "{{ dict(ansible_facts.devices | dict2items | json_query('[?value.model==`Amazon Elastic Block Store`].[value.serial, key]')) }}"

- debug:
    var: nvme_devices

- name: map ebs name to nvme name
  ansible.builtin.set_fact:
    drive_map: "{{ dict(ebs_devices.keys() | zip(nvme_2_ebs_list)) }}"
  vars:
    nvme_2_ebs_list: "{{ ebs_devices.values() | map('extract', nvme_devices) | map('regex_replace', '^(.*)$', '/dev/\\1') }}"

- debug:
    var: drive_map
